# Syntax (version 0.0.17)

### Character Classes
 - Whitespace: \\SPACE
 - Alphabetic: a b c d e f g h i j k l m n o p q r s t u v w x y z
   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \_
 - Punctuation: ! " # $ % & ' ( ) * + - . / : ; < = > ? @ [ \ ] ^ \` \{ | \}
 - Separator: \\n ,
 - Integer: 0 1 2 3 4 5 6 7 8 9 \_
 - Decimal: 0 1 2 3 4 5 6 7 8 9 \_ .
 - Hexdigit: 0 1 2 3 4 5 6 7 8 9 A B C D E F \_

### Literals
Aratar has no character type, because the amount of data a grapheme cluster
takes up is variable.

```aratar
1_234       # Integer
3.5         # Decimal
6.626_1e-34 # Scientific
2.0f        # Floating point
0xF2_A8     # Hexadecimal
0b1010_1111 # Binary
1.0+4.0i    # Complex Decimal
1.0f+f4.0i  # Complex Floating point
alphabetic  # Identifier (Lowercase only, no numbers allowed)
"Text 1"    # UTF-8 Text
Bool.TRUE   # Enum Variant (Uppercase only, no numbers allowed)
@1_234      # Mutable data
```

### Declaring A Variable
```aratar
# Int
let a: 1_000
# Hexadecimal
let a: 0xFF
# A function
let a: Opt.Int(text, parse) {
    if parse [
        TRUE { text.Int() } # Parse the text as an Int
        # Return the first unicode codepoint as an Int
        FALSE { SOME(text.codepoints().next()?.Int()) }
    ]
}

# Fully written out
let a Int.Min{0}: Int.Min{0}(1_000)
# Fully writen out Hexadecimal
let a Hex: Hex(xFF)
# A function fully written out
let a Fn{Opt.Int}(p Text, q Bool): fn{Opt.Int}(text Text, parse Bool) {
    let num: if parse [
        TRUE: { text.Int() } # Parse the text as an Int
        # Return the first unicode codepoint as an Int
        FALSE: { text.codepoints().next()?.Opt.Int() }
    ]
    return num
}
```

### Built-In Functions ("Intrinsics", but not really)
 - `fn`: Needed to define other functions, can't really get around that
 - `let`: Needed to put variables into scope.
 - `match: fn T R (variant T) [branches Map(Key(T), Fn() -> R)] -> R`: Branching
   building block

### Order of operations
There is no explicit order of operations - use `{}` or functions when using
operators.

```aratar
5 * x ^ 3 + 4 * x ^ 2 + 3 * x                # Doesn't compile
{5 * {x ^ 3}} + {4 * {x ^ 2}} + {3 * x}      # Compiles
sum[mul[5, x ^ 3], mul[4, x ^ 2], mul[3, x]] # Compiles
```

### Functions
```aratar
let sin: fn(num Float) -> Float {
    # code
}
3.0.sin()

# Function definition
let if: fn T (conditional Bool) {then -> T} -> T {
    match conditional [
        TRUE: then
        _: {}
    ]
}
# Function Call
if TRUE {
    out.info("Always runs")
}
```

## Examples
```aratar
# Use functional replacement for `and` and `or` statements.
if [[a = 2, a != 4].any()
    [b = 5, b = 7].any()
   ].all()
{
    info["a = ", a, " and b = ", b]
}
if [[a = 2, b = 5].all()
    [a != 4, b = 7].all()
   ].any()
{
    info["a = ", a, " and b = ", b]
}

# Declare a function that adds a list of numbers together.
let add: fn[numbers] -> _ {
    let ret: @Num.ZERO
    numbers.iter(fn(num) {
        ret +: num
    })
    ret
}

let b: 42
let var: @SOME(b)

# Maybe change `var` #

match var [
    SOME(b) {
        info["`var` was not changed"]
    }
    SOME(let a) {
        info["`var` changed inner value to ", a]
    }
    NONE {
        info["`var` changed to NONE"]
    }
]
```

## Syntactic Data Structures

### Sequences of Expressions
- `[]` - List: Same-typed (Literal Arrays/Vectors).
- `()` - Tuple: Different-typed (Parameters, Literal Tuples)
- `{}` - Block: Multiple expressions executed in sequence.

```aratar
# Fixed-Sized List
let list [Int; 4]: [1, 2, 3, 4]
# Dynamic-Sized List
let list [Int]: [1, 2, 3, 4]
# Infer
let list: [1, 2, 3, 4]
# Tuple
let tuple (Int, Text): (42, "Hello, world!")
# Block
let int Int: {
    let mutable @Int: @4
    Range(0, 4)
        .map(fn(_) { mutable +: 1 })
        .iterate()
    mutable
} # int = 8
# Closure / Function
let Int.Text: fn(num) -> Text {
    let ret @Text: (num < 0).then_else("-", "")
    let num @Int: num.abs()

    (fn() {
        let digit: num % 10
        let digit: if digit [
            0: { "0" }
            1: { "1" }
            2: { "2" }
            3: { "3" }
            4: { "4" }
            5: { "5" }
            6: { "6" }
            7: { "7" }
            8: { "8" }
            9: { "9" }
        ]
        ret ++: digit
        num /: 10
        if num = 0 [
            TRUE { NONE }
            FALSE { SOME(()) }
        ]
    })
        .FnIter()
        .iterate()

    ret
}
# List Functions
let multi_int_to_text: fn[numbers Int] -> Text {
    let ret @Text: @""
    numbers.enumerate()
        .map(fn((i, num)) {
            ret ++: num.Text()
            if i != sub(numbers.len, 1) {
                ret ++: ", "
            }
        })
        .iterate()
    ret
}
assert(multi_int_to_text[1, 2, 3] = "1, 2, 3")
```

All of these sequences implement `Transparent T` on one element, where the
element is type `T`.

```aratar
# Transparent allows using all types of brackets as parentheses
assert({[(1 + 1) * 2] * 2} * 2 = 16)
```

## Types
```aratar
$[Into String]
enum Try E T: [FAIL(E): 0, PASS(T): 1]
$[Into String, Into Try]
enum Opt T: [NONE: 0, SOME(@T): 1]
struct Complex: (real @Real, imag @Imaginary)
typedef Text: [Grapheme]
struct Range: (start Int, end Int)

# List of built-in types
Fn()
Bool
Text
Opt
Int
Float
Num
Double
Grapheme
AsciiText
AsciiChar
Data
Imaginary
Real
Complex
Dec
```

## Keyword List
```aratar
# Global Data Definitions
use     # Import a library/module definition `use aratar.fft{0.1}`
pub     # Public definition `pub fft: fn(@samples) { # ... # }`
def     # Private definition `def fft: fn(@samples) { # ... # }`
# Local Data Definitions
let     # Declare a variable `let @samples: [1, 2, 3, 4, 5, 6, 7, 8]`
# Global Type definitons
enum    # Define Associated Union Type
struct  # Define Record Type
typedef # Define Type Alias (Transparent, but type safe)
# Literal Constructs
fn      # "Function" A function defintion `def fft: fn(@samples) { # ... # }`
# Control Flow
if      # Conditional Branching / Pattern Matching
return  # Early return out of a function
```

## Ascii Token List
```
# # Comment / Doc Comment
+ # Add / Identity
- # Subtract / Negation
* # Multiply
/ # Divide
% # Modulo
^ # Exponentiate
& # Pattern Matching Filter (Can be chained)
| # Pattern Matching Or (Can be chained)
! # Pattern Matching Not
? # Try: Function Early Return If Not `Opt.SOME` / `Result.OK`
< # Less
> # More
= # Equal
. # Structure / Enum Access
, # Separator (In sequences)
" # Text Literals
; # Repetition (within [] lists)
: # Assignment (can have any operator before it to combine, not all work)
' # Naming of code blocks
` # Include raw text in file
@ # Mutable Reference
$ # Attribute
~ # Bitwise Not
&& # Bitwise And
|| # Bitwise Or
^^ # Bitwise Xor
++ # Concatenate
-- # Truncate
** # Dot Product / Matrix Multiply
// # Integer division
%% # Is divisible by
<< # Shift Left
>> # Shift Right
<= # Less Than / Equal To (`≤`)
>= # More Than / Equal To (`≥`)
!= # Not Equal To
#! # Interpreter selector at the top of file
#? # Module level documentation comment
```
